【疑问汇总】java 核心技术 36 讲
=======

## 1

- 温习类加载的过程:加载、验证、链接、初始化,熟悉每个阶段所做的事情

- 如何自定义Class-Loader？做一些扩展

- 对于将热点代码进行编译执行前，JVM 需要收集足够的信息进行分析，看看 JVM 如何收集的？profile 又是什么概念？

## 第2讲

- 检查和不可检查的异常区别是什么？分别怎么处理

- ClassNotFoundException和NoClassDefFoundError的区别是什么？

### 抽时间系统化总结基础类库，包括集合、IO/NIO、网络、并发、安全等基础类库

### 垃圾收集器，如SerialGC、Parallel GC、 CMS、 G1等，分别适用于什么样的工作负载？

### 什么是 JVM 的分层编译？

进入编译执行，然后随着时间的推移，执行频率较高的代码再被c2编译器编译，以达到最高的性能。

参考链接: https://www.jianshu.com/p/318617435789

2.1 纯编译执行(-Xcomp）

jvm提供了一个参数-Xcomp ,这个参数可以使jvm运行在纯编译的模式，所有的方法在第一次调用的时候就会编成机器代码
，但是现实的话，设置了这个参数之后系统启动负载的确没有上升，这验证了我们之前的猜测，
但是随之而来的问题，启动的时间是原来的两倍多，这对我们的应用是不好接受的，现在我们应用启动时间都快到3分钟。
所以纯编译不是我们的最优选择。不过，我们还有分层编译。

2.2 分层编译（-XX:+TieredCompilation)

除了纯编译和默认的mixed之外，jvm 从jdk6u25 之后，引入了分层编译。
HotSpot 内置两种编译器，分别是client启动时的c1编译器和server启动时的c2编译器，
c2在将代码编译成机器代码的时候需要搜集大量的统计信息以便在编译的时候进行优化，因此编译出来的代码执行效率比较高，
代价是程序启动时间比较长，而且需要执行比较长的时间，才能达到最高性能；
与之相反， c1的目标是使程序尽快进入编译执行的阶段，所以在编译前需要搜集的信息比c2要少，编译速度因此提高很多，
但是付出的代价是编译之后的代码执行效率比较低，但尽管如此，c1编译出来的代码在性能上比解释执行的性能已经有很大的提升，
所以所谓的分层编译，就是一种折中方式，在系统执行初期，执行频率比较高的代码先被c1编译器编译，
以便尽快

## 第3讲

- final 减少并发中的同步开销的原理是什么？(查看 java 虚拟机的说明)

- try with resources 如何使用？

> 平时的开发中 看 什么地方适合使用 final 关键字

- 如何实现深度拷贝（如构造对象时的成员变量的赋值）

- 并发编程中的 copy-on-write 原则是什么？

> Cleaner的实现利用了**幻象引用**(PhantomReference)，这是一种常见的所谓post-mortem清理机制

- 什么是 post-mortem清理机制？

## 第 4 讲

- 4 种引用写 java 实例来演示？

- JVM 可达性分析温习

## 第 5 讲

- 阅读 StringBuffer 和 StringBuilder 源码实现

- 查看 StringBuffer 如何实现线程安全，为什么性能开销比较大？


## 第 7 讲

- 研究一下 Integer 的静态工厂方法 valueOf,如何实现缓存？

- 阅读  Integer 源码，看包装类型的典型实现

- 为什么数组可以利用 CPU 的缓存，分散的对象引用/链表等不能？

- 部分比较宽的数据类型，比如float、double，甚至不能保证更新操作的原子性，可能出现程序读取到只更新了一半数据位的数值!这是为什么？


## 第 8 讲

- hashSet 根据 hashMap 实现，treeSet 根据 treeMap 实现,具体实现是什么样的？

- 自己手绘集合框架的设计结构

- 结合 数据结构与算法之美，掌握集合对应的数据结构和算法

- 集中整理和对比集合的性能和并发，哪些性能更好，支持并发

- 排序算法中哪些是稳定的？

- 外部排序，掌握利用内存和外部存储处理超大数据集，至少要理解过程和思路，找个例子去完整描述

## 第 9 讲

- 温习 《Effective Java》 有关 掌握hashCode和equals的内容，并练习重写 equals 和 hashcode

## 第 10 讲

- 什么是 CAS ? 如何保证并发的同步？

## 第11讲 | Java提供了哪些IO方式？ NIO如何实现多路复用？

- 学习一下 IO 相关的章节，特别是 NIO 的操作机制

- 什么是基于 流模型实现的 io

- 异步 IO 基于事件和回调机制，具体是怎么实现的？

- 同步是不是大部分是阻塞的，异步是不是大部分是非阻塞的

- 高并发下采用线程池的方式，线程的上下文切换开销很明显，线程为什么不是阻塞式的？是如何进行上下文切换的？

##

# 第16讲 | synchronized底层如何实现?什么是锁的升级、降级?

- 什么是安全点？

- 什么是对象头的 mark word? 

- 什么是锁膨胀？

- 什么是停顿(STW)

- 研究一下synchronized内部实现，结合 深入理解 JVM 总结各种锁和实现原理


# 第17讲

- 从线程 API使用部分一直到本节结束，不明白讲述的内容，需要查找额外资料和阅读源码理解

- 什么是守护线程(Daemon Thread)，实际在哪里应用？如何使用



## 第 讲
