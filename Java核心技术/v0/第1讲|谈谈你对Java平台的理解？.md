# Java 基础
# 第1讲|谈谈你对Java平台的理解？

### 问题
谈谈你对Java平台的理解? “Java是解释执行”，这句话正确吗?

## 典型回答

Java本身是一种面向对象的语言，最显著的特性有两个方面：

- 一是**跨平台**，即 **“书写一次，到处运行”**(Write once, run anywhere)

- 另外就是**垃圾收集**(GC, Garbage Collection)，Java通过垃圾收集器(Garbage Collector)回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。

我们日常会接触到 `JRE(Java Runtime Environment)` 或者 `JDK(Java Development Kit) `。 

- JRE，也就是**Java运行环境**，包含了JVM和Java类库，以及一些模块等。 
- JDK可以看作是JRE的一个超集，提供了更多工具，比如`编译器、各种诊断工具`等。

对于“Java是解释执行”这句话，这个说法不太准确。我们开发的Java的源代码，首先通过**Javac编译成为字节码**(bytecode)，然后，在运行时，通过 Java虚拟机(JVM)内嵌的**解释器将字节码转换成为最终的机器码**。但是常见的JVM，比如大多数情况使用的Oracle JDK提供的Hotspot JVM，都提供了**JIT(Just-In-Time)编译器**，也就是通常所说的 **及时编译器**，JIT能够在运行时**将热点代码编译成机器码**，这种情况下部分热点代码就属于编译执行，而不是解释执行了。

```
@yx
对于方法调用的热点代码检测，client 模式下默认为 1500次，server 模式下为 10000次。
```

## 考点分析

对于这类笼统的问题，你需要**尽量表现出自己的思维深入并系统化，Java知识理解得也比较全面**，一定要避免让面试官觉得你是个“知其然不知其所以然”的人。毕竟明白基本组成和机制，是日常工作中进行问题诊断或者性能调优等很多事情的基础。

> 即使感觉自己的回答不是非常完善，也不用担心。
> 
> 我个人觉得这种笼统的问题，有时候回答得稍微片面也很正常，大多数有经验的面试官，不会因为一道题就对面试者轻易地下结论。
> 
> 通常会尽量引导面试者，把他的真实水平展现出来，这种问题就是做个开场热身，`面试官经常会根据你的回答扩展相关问题`。

## 知识扩展
对于Java平台的理解，可以从很多方面简明扼要地谈一下，例如:

- Java语言特性，包括泛型、Lambda等语言特性
- 基础类库，包括**集合、IO/NIO、网络、并发、安全**等基础类库。对于我们**日常工作应用较多的类库，面试前可以系统化总结一下**，有助于临场发挥。

或者谈谈JVM的一些基础概念和机制，例如:

- Java的类加载机制，常用版本JDK(如JDK 8)内嵌的Class-Loader，例如Bootstrap、Extension 和 Application Class-loader
- 类加载大致过程:加载、验证、链接、初始化
- 自定义Class-Loader
- 垃圾收集的基本原理，最常见的垃圾收集器，如SerialGC、Parallel GC、 CMS、 G1等，对于适用于什么样的工作负载最好也心里有数,这些都是可以扩展开的领域

当然还有JDK包含哪些工具或者Java领域内其他工具等，例如:

- 编译器、运行时环境、安全工具、诊断和监控工具等。这些基本工具是日常工作效率的保证，对于我们工作在其他语言平台上，同样有所帮助，很多都是触类旁通的。

下图是我总结的一个相对宽泛的蓝图供你参考。

<div align="center"> <img src="pics/1-1.png" width="500" style="zoom:100%"/> </div><br>
    
回到前面问到的**解释执行和编译执行**的问题。有些面试官喜欢在特定问题上“刨根问底儿”，因为这是进一步了解面试者对知识掌握程度的有效方法，我稍微深入探讨一下。

通常把Java分为**编译期和运行时**。这里说的Java的编译和C/C++是有着不同的意义的，Javac的编译，编译Java源码生成“.class”文件里面实际是字节码，而不是可以直接执行的机器码。Java通过**字节码和Java虚拟机(JVM)这种跨平台的抽象**，屏蔽了操作系统和硬件的细节，这也是实现“一次编译，到处执行”的基础。

> @yx
> 
> 所谓的解释执行，我们需要感谢一下 JVM 中的解释器这位大兄弟，他让我们启动 java 应用时，不需要等待所有的代码编译为机器码再运行(这可能是个“漫长”的等待)，
> 他会逐条将字节码解释为机器码，立即执行，节省了内存。是不是应该给他颁发一个“奖状”。(好吧，我承认他不如编译好运行快，毕竟“鱼与熊掌不可兼得嘛”)

在运行时，JVM会通过**类加载器(Class-Loader)加载字节码，解释或者编译执行**。 就像我前面提到的，主流Java版本中，如JDK 8实际是解释和编译混合的一种模式，即所谓的**混合模式**(-Xmixed)。

> 通常运行在server模式的JVM，会进行上万次调用以收集足够的信息进行高效的编译，client模式这个门限是1500次。

 Oracle Hotspot JVM内置了两个不同的JIT compiler：

- C1对应前面说的client模式，适用于对于启动速度敏感的应用，比如普通Java桌面应用;
- C2对应server模式，它的优化是为长时间运行的服务器端应用设计的。 

> 默认是采用所谓的分层编译(TieredCompilation)。

Java虚拟机启动时，可以**指定不同的参数对运行模式进行选择**。 比如:

- 指定“-Xint”，就是告诉JVM只进行解释执行，不对代码进行编译，这种模式抛弃了JIT可能带来的性能优势。 毕竟解释器(interpreter)是逐条读入，逐条解释运行的。

- 与其相对应的，还有一个“-Xcomp”参数，这是告诉JVM关闭解释器，不要进行解释执行，或者叫作**最大优化级别**。那你可能会问这种模式是不是最高效啊?简单说，还真未必。“-Xcomp”会导致JVM启动变慢非常多，同时有些JIT编译器优化方式，比如分支预测，如果不进行 profiling，往往并不能进行有效优化。

除了我们日常最常见的Java使用模式，其实还有一种**新的编译方式，即所谓的AOT**(Ahead-of-Time Compilation)，**直接将字节码编译成机器代码**，这样就避免了JIT预热等各方面的开销，比如Oracle JDK 9就引入了实验性的AOT特性，并且增加了新的jaotc工具。利用下面的命令把某个类或者某个模块编译成为AOT库。

	jaotc --output libHelloWorld.so HelloWorld.class 
	jaotc --output libjava.base.so --module java.base

然后，在启动时直接指定就可以了。

	java -XX:AOTLibrary=./libHelloWorld.so,./libjava.base.so HelloWorld
	
而且，Oracle JDK支持分层编译和AOT协作使用，这两者并不是二选一的关系。如果你有兴趣，可以[参考相关文档](http://openjdk.java.net/jeps/295)。AOT也不仅仅是只有这 一种方式，业界早就有第三方工具(如GCJ、Excelsior JET)提供相关功能。

另外，JVM作为一个强大的平台，不仅仅只有Java语言可以运行在JVM上，本质上**合规的字节码都可以运行**，Java语言自身也为此提供了便利，我们可以看到类 似Clojure、Scala、Groovy、JRuby、Jython等大量JVM语言，活跃在不同的场景。

