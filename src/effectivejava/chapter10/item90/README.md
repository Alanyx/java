# 考虑用序列化代理代替序列化实例

## 序列化代理模式

实现 Serializable 接口，会增加出错和安全问题的可能性，因为它允许利用语言之外的机制来创建实例，而不是使用普通的构造器。

===》 有一个方法可以极大的减少这些风险，那是 序列化代理模式（seralization proxy pattern）。

## 实现方式

- 首先，为可序列化的类设计一个私有的静态嵌套类，表示外部类的逻辑状态。这个嵌套类被称为序列化代理（seralization proxy），它应该有一个单独的构造器，其参数类型就是那个外围类。

- 这个构造器只从它的参数中复制数据：它不需要进行任何一致性检验或者保护性拷贝。

> 从设计的角度看，序列化代理的默认序列化形式是外部类最好的序列化形式。

⚠️: 外部类及其序列代理都必须声明实现 Serializable 接口。

- 序列化代理模式允许反序列化实例有着与原始序列化实例不同的类。【如 EnumSet 序列化代理】

## 优点

序列化代理方式可以阻止伪字节流的攻击以及内部字段的盗用攻击。

> 与前两种方法不同，这种方法允许 Period 类的字段为 final，为了确保 Period 类是真正不可变的，这一点非常重要。

## 局限性

### 不能与可以被客户端拓展的类兼容（详见 19 条），也不能与对象图中包含循环的某些类兼容

如果你企图从一个对象的序列化代理的 readResovle 方法内部调用这个对象的方法，就会得到一个 ClassCastException 异常，因为你还没有这个对象，只有它的序列化代理。

### 开销变大

序列化代理模式所增强的功能和安全性不是没有代价，通过序列化代理来序列化和反序列化实例的开销更大。

## 小结

当你必须在一个不能被客户端拓展的类上面编写 readObject 或者 writeObject 方法时，就应该考虑使用序列化代理模式。

想要稳健地将带有重要约束条件的对象序列化时，这种模式是最容易的方法。