# 考虑使用自定义序列化形式

## 建议

### 在没有考虑清楚默认序列化形式是否合适之前，不要采用它。

### 如果对象的物理表示与逻辑内容相同，则默认的序列化形式可能是合适的。 

- 即使默认的序列化形式是合适的，你通常也必须提供 readObject 方法来确保不变性和安全性。

### 对象的物理表示与其逻辑数据内容有很大差异时，使用默认的序列化形式有四个缺点：【参见例子:StringList】

- 它将导出的 API 永久地绑定到当前的内部实现。

> 例子中，私有 StringList.Entry 类成为公共 API 的一部分。如果在将来的版本中更改了实现，StringList 类仍然需要接受链表形式的输出，并产生链表形式的输出。
>
> 这个类永远也摆脱不掉处理链表项所需要的所有代码，即使不再使用链表作为内部数据结构。

- 它会占用过多的空间。 

> 例中，序列化的形式不必要地表示链表中的每个条目和所有链接关系。链表项以及链接只不过是实现细节，不值得记录在序列化形式中。
>
> 因为这样的序列化形式过于庞大，将其写入磁盘或通过网络发送将非常慢。

- 它会消耗过多的时间。 

> 序列化逻辑不知道对象图的拓扑结构，因此要遍历开销很大的图。例子中，只要遵循 next 的引用就足够了。

- 它可能导致堆栈溢出。 

> 默认序列化过程使用对象图的递归遍历，即使中等规模的对象图，这也可能导致堆栈溢出。用 1000-1800 个元素序列化 StringList 实例会在我的机器上生成一个 StackOverflowError。
> 
> 令人惊讶的是，序列化导致堆栈溢出的最小列表大小因运行而异。此问题的最小列表大小可能取决于平台实现和命令行标志；有些实现可能没有这个问题。

### 对于任何不变量绑定到特定于实现的细节的对象，情况并非如此。

> 例如考虑哈希表。物理表示是包含「键-值」项的哈希桶序列。一个项所在的桶是其键的散列代码的函数，通常不能保证从一个实现到另一个实现是相同的。
>
> 事实上，它甚至不能保证每次运行都是相同的。因此，接受哈希表的默认序列化形式将构成严重的 bug。对哈希表进行序列化和反序列化可能会产生一个不变量严重损坏的对象。

### 序列化执行同步

无论是否使用默认的序列化形式，必须对对象序列化强制执行任何同步操作，就像对读取对象的整个状态的任何其他方法强制执行的那样。

```
// writeObject for synchronized class with default serialized form
private synchronized void writeObject(ObjectOutputStream s) throws IOException {
    s.defaultWriteObject();
}
```

### 无论选择哪种序列化形式，都要在可序列化类中声明显式的序列版本 UID。 

    如 private static final long serialVersionUID = randomLongValue;

- 新类，为 randomLongValue 选择什么值并不重要。

> 可以在类上运行 serialver 实用工具来生成该值，但是也可以凭空选择一个数字。串行版本 UID 不需要是唯一的。

- 修改缺少串行版本 UID 的现有类: 希望新版本接受现有序列化实例，则必须使用为旧版本自动生成的值。 

> 你可以通过在类的旧版本上运行 serialver 实用工具（序列化实例存在于旧版本上）来获得这个数字。


## 小结

总之，如果决定一个类是可序列化的，请仔细考虑一下序列化的形式应该是什么。

只有合理描述对象的逻辑状态时，才使用默认的序列化形式；否则，设计一个适合描述对象的自定义序列化形式。

设计类的序列化形式应该和设计导出方法花的时间应该一样多，都应该严谨对待（详见第 51 条）。

> 正如不能从未来版本中删除导出的方法一样，也不能从序列化形式中删除字段；必须永远保存它们，以确保序列化兼容性。
>
> 选择错误的序列化形式可能会对类的复杂性和性能产生永久性的负面影响。






