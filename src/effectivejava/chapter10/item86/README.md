# 谨慎实现 Serializable

## 为什么要谨慎实现？

### 代价1: 一旦类的实现被发布，它就会降低更改该类实现的灵活性

- 如果接受默认序列化形式，然后更改了类的内部实现，会导致与序列化形式不兼容。

> 试图使用类的旧版本序列化实例，再使用新版本反序列化实例的客户端（反之亦然）程序将会失败。

- 然而即使设计良好的序列化形式，也会限制类的演化；而设计不良的序列化形式，可能会造成严重后果。

> 施加这种约束的一个简单示例涉及流的唯一标识符，通常称其为串行版本 UID。每个可序列化的类都有一个与之关联的唯一标识符。
>
> 如果没有声明 serialVersionUID 的 static final long 字段指定这个标识符，系统将在运行时对类应用加密散列函数（SHA-1）自动生成它。
>
> 这个值受到类的名称、实现的接口及其大多数成员（包括编译器生成的合成成员）的影响。如果你更改了其中任何一项，例如，通过添加一个临时的方法，生成的序列版本 UID 就会更改。如果你未能声明序列版本 UID，兼容性将被破坏，从而在运行时导致 InvalidClassException。

### 代价2: 增加了出现 bug 和安全漏洞的可能性(第85项)

- 序列化是一种用于创建对象的超语言机制

> 反序列化是一个「隐藏构造函数」，其他构造函数具有的所有问题它都有。
>
> 很容易忘记必须让它保证所有的不变量都是由构造函数建立，并且不允许攻击者访问正在构造的对象内部。

### 代价3: 增加了与发布类的新版本相关的测试负担

可序列化类被修改时，检查是否可以在新版本中序列化一个实例很重要，并在旧版本中反序列化它，反之亦然。

必须确保「序列化-反序列化」过程成功，并确保它生成原始对象的无差错副本。

## 其他情况

### 为继承而设计的类（详见第 19 条）很少适合实现 Serializable 接口，接口也很少情况适合扩展它。

例外: 如果一个类或接口是为了参与一个要求所有参与者都实现 Serializable 接口的框架，那么实现或扩展 Serializable 可能是有意义的。

> eg: 在为了继承而设计的类中，Throwable 类和 Component 类都实现了 Serializable 接口。正是因为 Throwable 实现了 Serializable 接口，RMI 可以将异常从服务器发送到客户端。

### 如果实现了一个带有实例字段的类，它同时是可序列化和可扩展的，那么需要注意几个风险。

- 实例字段值上有不变量，关键是要防止子类覆盖 finalize 方法，可以通过覆盖 finalize 并声明它为 final 来做到。

- 如果实例字段初始化为默认值（整数类型为 0，布尔值为 false，对象引用类型为 null），必须添加 readObjectNoData 方法

```
// readObjectNoData for stateful extendable serializable classes
private void readObjectNoData() throws InvalidObjectException(){
    throw new InvalidObjectException("Steam data required");
}
```

### 内部类（详见第 24 条）不应该实现 Serializable。但是，静态成员类可以实现 Serializable 接口。

> 它们使用编译器生成的合成字段 存储对外围实例的引用，并存储外围的局部变量的值。这些字段与类定义的对应关系，和没有指定匿名类和局部类的名称一样。因此，内部类的默认序列化形式是不确定的。

