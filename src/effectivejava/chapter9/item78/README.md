## 同步访问共享的可变数据

## 同步
如果没有同步，一个线程的变化 不能 被其他线程看到。

同步可以阻止一个线程看到对象处于不一致状态，还可以保证进入同步方法或同步代码块的每个线程，都能看到同一个锁保护的之前的修改状态。

为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。

> 虽然语言规范保证了线程在读取原子数据时，不会看到任意的数值，但是它并不保证一个线程写入的值对于另一个线程将是可见的。

## 原子性

Java 语言规范保证读或者写一个变量是原子的（ atomic ），除非这个变量的类型为 long 或者 double 。

long 或者 double 类型变量的读 / 写操作在 32 位 Java 虚拟机下可能会被分解为两个子步骤（比如先写低 32 位，再写高 32 位）来实现，
这就导致一个线程对 long/double 型变量进行的写操作的中间结果可以被其他线程所观察到，此时针对 long/double 型变量的访问操作不是原子操作。

 ## 千万不要使用 Thread.stop 方法
 
 Java 的类库中提供了 Thread.stop 方法，但是在很久以前就不提倡使用该方法了，因为它本质上是不安全的一一使用它会导致数据遭到破坏。  

 - 要一个线程阻止另一个线程，建议让第一个线程轮询（ poll ） 一个 boolean 字段，这个字段一开始为 false ，但是可以通过第二个线程设置为 true ，以表示第一个线程将终止。

 > 由于 boolean 字段的读和写操作都是原子的，在访问这个字段时 不再需要使用同步。

## 最佳方法-不共享可变数据

要么共享不可变的数据（详见第 17 条），要么压根不共享。 即将可变数据限制在单个线程中。

## 其他方式

### 高效不可变（ effectively immutable )

让一个线程在短时间内修改一个数据对象，然后与其他线程共享，它只同步共享对象引用的动作。
然后其他线程没有进一步的同步也可以读取对象，只要它没有再被修改。这种对象被称作高效不可变（ effectively immutable ) 

### 安全发布（ safe publication)

- 定义: 将高效不可变对象引用从一个线程传递到其他的线程称作安全发布（ safe publication) 

安全发布对象引用有许多种方法：

- 可以将它保存在静态字段中，作为类初始化的一部分
- 可以将它保存在 volatile 字段、final 字段或者通过正常锁定访问的字段中
- 或者可以将它放到并发的集合中（详见第 81 条）


## 小结

总之，当多线程共享可变数据时，每个读或写数据的线程都必须执行同步。 

如果没有同步，就无法保证一个线程所做的修改可以被另一个线程获知。

未同步共享可变数据会造成程序的活性失败（ liveness failure ）和安全性失败（ safety failure ）。这样的失败是最难调试的。它们可能是间歇性的，且与时间相关，程序的行为在不同的虚拟机上可能根本不同。

如果只需要线程之间的交互通信，而不需要互斥，volatile 修饰符是一种可以接受的同步形式，但要正确地使用它可能需要一些技巧。