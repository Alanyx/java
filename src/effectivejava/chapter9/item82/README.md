# 文档应该包含线程安全属性

## 常见的线程安全级别

要启用安全的并发使用，类必须清楚地记录它支持的线程安全级别。

- 不可变的 — 此类实例看起来是常量。不需要外部同步。

> 如 String、Long 和 BigInteger（详见第 17 条）。

- 无条件线程安全 — 该类的实例是可变的，但是该类具有足够的内部同步，因此无需任何外部同步即可并发地使用该类的实例。

> 如 AtomicLong 和 ConcurrentHashMap。

- 有条件的线程安全 — 与无条件线程安全类似，只是有些方法需要外部同步才能安全并发使用。

> 包括 Collections.synchronized 包装器返回的集合，其迭代器需要外部同步。

``` java
// 当用户遍历其集合视图时，必须手动同步返回的 Map：

Map<K, V> m = Collections.synchronizedMap(new HashMap<>());
Set<K> s = m.keySet(); // Needn't be in synchronized block
...
synchronized(m) { // Synchronizing on m, not s!
    for (K key : s)
        key.f();
}
```

- 非线程安全 — 该类的实例是可变的。要并发地使用它们，客户端必须使用外部同步来包围每个方法调用（或调用序列）。

> 如通用的集合实现，例如 ArrayList 和 HashMap。

- 线程对立 — 即使每个方法调用都被外部同步包围，该类对于并发使用也是不安全的。线程对立通常是由于在不同步的情况下修改静态数据而导致的。没有人故意编写线程对立类；此类通常是由于没有考虑并发性而导致的。当发现类或方法与线程不相容时，通常将其修复或弃用。

> 第 78 条中的 generateSerialNumber 方法在没有内部同步的情况下是线程对立的。

```
这些类别（不包括线程对立类）大致对应于《Java Concurrency in Practice》中的线程安全，分别为 Immutable、ThreadSafe 和 NotThreadSafe。
上面分类中的无条件线程安全和有条件的线程安全都包含在 ThreadSafe 注解中。
```

### 私有锁 🔒 细节设计

因为私有锁对象在类之外是不可访问的，所以客户端不可能干扰对象的同步。实际上，我们通过将锁对象封装在它同步的对象中，是在应用条目 15 的建议。

⚠️ lock 字段应该被声明为 final。可以防止无意中更改它的内容，这可能导致灾难性的非同步访问（详见 78 条）。为了最小化锁字段的可变性。Lock 字段应该始终声明为 final(条目 17)。 无论使用普通的监视器锁还是 java.util.concurrent 包中的锁，都是这样。

私有锁对象用法只能在无条件的线程安全类上使用。有条件的线程安全类不能使用这种用法，因为它们必须在文档中记录，在执行某些方法调用序列时要获取哪些锁。

私有锁对象用法特别适合为继承而设计的类（详见第 19 条）。如果一个类要使用它的实例进行锁定，那么子类很容易在无意中干扰基类的操作，反之亦然。

通过为不同的目的使用相同的锁，子类和基类最终可能「踩到对方的脚趾头」。这不仅仅是一个理论问题，它就发生在 Thread 类中。


## 小结

总之，每个类都应该措辞严谨地描述或使用线程安全注释记录其线程安全属性。

synchronized 修饰符在文档中没有任何作用。

有条件的线程安全类必须记录哪些方法调用序列时需要外部同步，以及执行这些序列时需要获取哪些锁。

如果你编写一个无条件线程安全的类，请考虑使用一个私有锁对象来代替同步方法。这将保护你免受客户端和子类的同步干扰，并为你提供更大的灵活性，以便在后续的版本中采用复杂的并发控制方式。