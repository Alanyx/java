17. 最小化可变性
===

## 优先使用不可变类有什么优势？

- 不可变类比可变类更容易设计，实现和使用。 

- 不可变对象**本质上是线程安全的; 它们不需要同步**。[线程安全最简单的实现方式]

	> 由于不可变可以自由的共享，鼓励重用
- 不可变对象提供了**天然的原子失败机制**（详见第 76 条）。 

	> 它们的状态永远不会改变，所以不可能出现临时的不一致。

#### 不可变类有什么劣势？

- 主要缺点是**对于每个不同的值都需要一个单独的对象**。创建这些对象可能代价很高，特别是如果是大型的对象下。

	> 比如循环处理百万位的 BigInteger ,最后只输出一个数。
	>
	> 一个典型的解决例子: String类的可变伙伴类 StringBuilder（及其过时的前身 StringBuffer)

#### 要使一个类不可变，需要怎么做？

请遵循以下五条规则：

1. **不要提供修改对象状态的方法**（也称为 mutators）。

1. **确保这个类不能被继承**。 

	> 这可以防止粗心的或恶意的子类，假设对象的状态已经改变，从而破坏类的不可变行为。
	> 防止子类化通常是通过 final 修饰类。
	
1. **把所有属性设置为 final**。 

	通过系统强制执行，清楚地表达了你的意图。 另外，如果一个新创建的实例的引用从一个线程传递到另一个线程而没有同步，就必须保证正确的行为，正如内存模型所述。
1. **把所有的属性设置为 private**。 

	这可以防止客户端获得对属性引用的可变对象的访问权限并直接修改这些对象。

1. 确保对任何可变组件的互斥访问。 

	如果你的类有任何引用可变对象的属性，请确保该类的客户端无法获得对这些对象的引用。切勿将这样的属性初始化为客户端提供的对象引用，或从访问方法返回属性。 在构造方法，访问方法和 readObject 方法（详见第 88 条）中进行防御性拷贝（详见第 50 条）。
	
## 总结

总之:

- **坚决不要为每个属性编写一个 get 方法后再编写一个对应的 set 方法。 除非有充分的理由使类成为可变类，否则类应该是不可变的。** 

> 不可变类提供了许多优点，唯一的缺点是在某些情况下可能会出现性能问题。
> 
> 你应该始终使用较小的值对象（如 PhoneNumber 和 Complex），使其不可变。 （Java 平台类库中有几个类，如 java.util.Date 和 java.awt.Point，本应该是不可变的，但实际上并不是）。
> 
> 你应该认真考虑创建更大的值对象，例如 String 和 BigInteger ，设成不可改变的。

- 只有当你确认有必要实现令人满意的性能（详见第 67 条）时，才应该为不可改变类提供一个公开的可变伙伴类(如 StringBuffer)。

- 对于一些类来说，不变性是不切实际的。**如果一个类不能设计为不可变类，那么也要尽可能地限制它的可变性**。减少对象可以存在的状态数量，可以更容易地分析对象，以及降低出错的可能性。因此，除非有足够的理由把属性设置为非 final 的情况下，否则应该每个属性都设置为 final 的。自然的倾向就是：**除非有充分的理由不这样做，否则应该把每个属性声明为私有 final 的**。

- **构造方法应该创建完全初始化的对象，并建立所有的不变性**。

	> 除非有令人信服的理由，否则不要提供独立于构造方法或静态工厂的公共初始化方法，建议尽量不要提供这样的公共初始化方法。

- 同样，**不要提供一个“reinitialize”方法**，使对象可以被重用，就好像它是用不同的初始状态构建的。这样的方法通常以增加的复杂度为代价，仅仅提供很少的性能优势。

	> CountDownLatch 类是这些原理的例证。 它是可变的，但它的状态空间有意保持最小范围内。 创建一个实例，使用它一次，并完成：一旦 countdown 锁的计数器已经达到零，不能再重用它。