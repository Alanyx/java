Java 编程思想
=====

# 12 | 通过异常处理错误
**java 的基本理念: “结构不佳的代码不能运行”。**

发现错误最好的理想时机是什么时候？
 
====》 当然是在**编译阶段**(运行代码之前)

> 然而并不是所有的问题都能在编译期发现，余下的问题就要在 **运行期** 解决啦

改进的错误恢复机制是保证 **代码健壮性** 的最强有力的方式。 

> java的异常处理的目的就是通过使用少量的代码来简化大型、可靠的程序开发

异常处理是 java 中**唯一正式的错误报告机制**，并通过编译器强制执行。

## 概念

我们使用异常有什么好处呢？

一般能够**降低错误处理代码的复杂度**。不仅节省代码，还将逻辑代码与异常处理代码**分离**。

> 如果不使用异常，就必须检查特定的错误，并在程序中很多地方去实现它。
> 
> 如果使用异常则无需在 方法调用处检查 ===》因为异常机制会保证捕获这个异常。并且在 `异常处理程序` 中统一处理错误。

## 基本异常

### 1. 异常情形
指阻止当前方法或者作用域继续执行的问题。

> 对于这样的异常情形，我们没法继续运行下去了 ====》因为在当前环境下没法获得必要的信息来解决问题。

> 我们能做的就是从当前环境跳出，把问题抛给上一级环境 ====》 就是**抛出异常**时发生的事情。

这么说是不是有点抽象？我们来举个例子。

> 除法就是一个简单的例子。除数有可能为 0 ，所以先检查很有必要。如果当前环境，除数为 0 是一个意外的值，你也不知道如何处理，就要抛出异常，而不是继续执行下去。

抛出异常后会发生几件事情:

1. 首先，同 java 其他对象创建一样，将用 new 在堆上创建异常对象
2. 然后，当前执行路径被终止，并从当前环境中弹出异常对象的引用
3. 此时，异常处理机制接管程序，开始寻找一个恰当的地方(即**异常处理程序**) 继续执行程序
4. 异常处理程序将程序从错误状态恢复:要么换一种方式运行，要么继续运行下去

我们来举个例子说明下。

对于引用 t ，传给你时可能未初始化，在使用前先进行检查。可以创建一个代表错误信息的对象，从当前环境抛出，把错误传播到“更大”的环境中，这就是 **抛出一个异常。**

	if (t == null) {
		throw new NullPointerException();
	}

异常允许我们强制程序停止运行，并告诉我们出了什么问题，或者(理想状态下)强制程序处理问题，并返回到稳定状态。

### 1.1 异常参数

所有标准异常类有两个构造器:

- 默认构造器
- 接收字符串作为参数，把相关信息放入异常对象的构造器

		throw new NullPointerException("t == null");

在使用了 new 创建了异常对象后 =====》对象的引用传给 throw

异常返回的“地点”与普通方法的返回“地点”完全不同。

> 异常将在一个恰当的异常处理程序中解决，位置可能离异常被抛出的地方很远，也可能跨越方法方法调用栈的许多层次。

**Throwable** 对象是异常类型的根类。

通常，不同类型的错误抛出相应的异常。错误信息可以**保存在异常对象内部**或**直接哟异常的名称**暗示。

> 如 NullPointerException、ArrayIndexOutOfBoundsException等。

## 捕获异常

要理解如何捕获异常，我们首先要理解什么是**监控区域**？

- 它是一段可能产生异常的代码，后面跟着处理这些异常的代码。

### try 块

若在**方法内部抛出异常 或 方法内部调用的其他方法抛出异常**(注意这里有 2 种情形)，这个方法将在抛出异常的过程中结束。

如果不想就此结束 ====》在方法内部设置一个特殊块捕获异常， 因为在这个块里尝试各种方法调用，所以叫 try 块。

	如:
	
	try {
		// code might generate exceptions
	}

> 相比于不支持异常处理的语言，这样做的好处在于: 逻辑/业务代码没有和错误检查代码混在一起。

### 异常处理程序
